function Yfit=forecastSDAE(trainX,trainY,testX)
[trainX,~] = mapminmax(trainX',-1,1);
[testX,~] = mapminmax(testX',-1,1);
[trainY,PStrainY] = mapminmax(trainY',-1,1);

hiddenSize1 = 200;
hiddenSize2 = 100;
% options={...
%     'MaxEpochs',500,...
%     'EncoderTransferFunction','logsig',...
%     'DecoderTransferFunction','logsig',...
%     'L2WeightRegularization',0.01,...
%     'SparsityRegularization',0,...
%     'ShowProgressWindow',false,...
%     'ScaleData',false};

options={...
    'MaxEpochs',500,...
    'EncoderTransferFunction','logsig',...
    'DecoderTransferFunction','logsig',...
    'L2WeightRegularization',0.01,...
    'SparsityRegularization',0,...
    'ShowProgressWindow',false,...
    'ScaleData',true,...
    'UseGPU',false};

ae1 = trainAutoencoder(trainX,hiddenSize1,options{:});
features1 = encode(ae1,trainX);
ae2 = trainAutoencoder(features1,hiddenSize2,options{:});
features2 = encode(ae2,features1);

fnn = feedforwardnet(10,'trainscg');
fnn.layers{1}.transferFcn='purelin';
fnn.layers{2}.transferFcn='purelin';
fnn.divideFcn = 'dividetrain';
fnn.trainParam.epochs=500;
fnn.trainParam.showWindow = false;
fnn.performParam.regularization=0.0001;
fnn = train(fnn,features2,trainY);
sDAE = stack(ae1,ae2,fnn);
view(sDAE)

sDAE = train(sDAE,trainX,trainY);
Yfit = sDAE(testX);
Yfit=mapminmax('reverse',Yfit,PStrainY);
Yfit=Yfit';

